<pre>

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   MIGRATION STRATEGY: JSON â†’ SQLite                     â”‚
â”‚              (Upgrading Part 1 Apps to Part 2 with Databases)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 MIGRATION OVERVIEW
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FROM: JSON File Storage (Part 1)
  â€¢ students.json with array of objects
  â€¢ Read entire file on every request
  â€¢ Write entire file on every update
  â€¢ No validation, no relationships

TO: SQLite Database (Part 2)
  â€¢ students table with typed columns
  â€¢ Query only needed records
  â€¢ Update individual rows
  â€¢ Constraints, relationships, transactions


MIGRATION PHASES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Phase 1: Design schema (tables, columns, constraints)
Phase 2: Create database and tables
Phase 3: Import existing JSON data
Phase 4: Update application code (fs â†’ db queries)
Phase 5: Test and verify
Phase 6: Deploy


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 PHASE 1: DESIGN SCHEMA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BEFORE (JSON Structure):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

students.json:
[
  {
    "id": 1,
    "studentId": "2024-0001",
    "name": "Juan Cruz",
    "age": 16,
    "grade": "10-A",
    "section": "Grade 10-A"
  },
  {
    "id": 2,
    "studentId": "2024-0002",
    "name": "Maria Santos",
    "age": 15,
    "grade": "10-B",
    "section": "Grade 10-B"
  }
]


ANALYZE JSON STRUCTURE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Identify fields and their types
   â€¢ id â†’ INTEGER (primary key)
   â€¢ studentId â†’ TEXT (unique identifier)
   â€¢ name â†’ TEXT (split into first_name, last_name?)
   â€¢ age â†’ INTEGER (add validation)
   â€¢ grade â†’ TEXT
   â€¢ section â†’ TEXT (should be relationship?)

2. Find data duplication
   â€¢ section stored in every student (redundant!)
   â€¢ Should normalize: create sections table

3. Identify relationships
   â€¢ Many students â†’ One section (one-to-many)

4. Add missing features
   â€¢ Timestamps (created_at, updated_at)
   â€¢ Email field (for contact)
   â€¢ Active status flag


AFTER (Database Schema):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

-- Sections table (normalized)
CREATE TABLE sections (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL UNIQUE,
  adviser TEXT NOT NULL,
  room TEXT NOT NULL,
  capacity INTEGER DEFAULT 35,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Students table (with foreign key)
CREATE TABLE students (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  student_id TEXT NOT NULL UNIQUE,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  email TEXT UNIQUE,
  age INTEGER CHECK (age >= 0 AND age <= 120),
  section_id INTEGER NOT NULL,
  is_active INTEGER DEFAULT 1,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (section_id) REFERENCES sections(id) ON DELETE CASCADE
);

-- Indexes for performance
CREATE INDEX idx_students_section ON students(section_id);
CREATE INDEX idx_students_email ON students(email);


IMPROVEMENTS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ… Normalized data (sections separate from students)
âœ… Foreign key relationship (data integrity)
âœ… Data types and constraints (validation)
âœ… Unique constraints (prevent duplicates)
âœ… Timestamps (audit trail)
âœ… Indexes (performance)


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 PHASE 2: CREATE DATABASE AND TABLES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

MIGRATION SCRIPT: setup-database.js
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const Database = require('better-sqlite3');
const path = require('path');

// Create database file
const db = new Database(path.join(__dirname, 'school.db'));

console.log('Creating database schema...');

// Enable foreign keys (important!)
db.prepare('PRAGMA foreign_keys = ON').run();

// Create sections table
db.exec(`
  CREATE TABLE IF NOT EXISTS sections (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    adviser TEXT NOT NULL,
    room TEXT NOT NULL,
    capacity INTEGER DEFAULT 35,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  );
`);

console.log('âœ… sections table created');

// Create students table
db.exec(`
  CREATE TABLE IF NOT EXISTS students (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    student_id TEXT NOT NULL UNIQUE,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT UNIQUE,
    age INTEGER CHECK (age >= 0 AND age <= 120),
    section_id INTEGER NOT NULL,
    is_active INTEGER DEFAULT 1,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (section_id) REFERENCES sections(id) ON DELETE CASCADE
  );
`);

console.log('âœ… students table created');

// Create indexes
db.exec(`
  CREATE INDEX IF NOT EXISTS idx_students_section ON students(section_id);
  CREATE INDEX IF NOT EXISTS idx_students_email ON students(email);
`);

console.log('âœ… indexes created');
console.log('Database setup complete!');

db.close();


RUN SCRIPT:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

$ node setup-database.js

Output:
  Creating database schema...
  âœ… sections table created
  âœ… students table created
  âœ… indexes created
  Database setup complete!


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 PHASE 3: IMPORT EXISTING JSON DATA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

MIGRATION SCRIPT: import-json-data.js
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const Database = require('better-sqlite3');
const fs = require('fs');
const path = require('path');

const db = new Database(path.join(__dirname, 'school.db'));

// Read existing JSON file
const jsonData = JSON.parse(
  fs.readFileSync(path.join(__dirname, 'students.json'), 'utf8')
);

console.log(`Found ${jsonData.length} students in JSON file`);

// Step 1: Extract unique sections from JSON
const sectionsMap = new Map();

jsonData.forEach(student => {
  if (!sectionsMap.has(student.section)) {
    sectionsMap.set(student.section, {
      name: student.section,
      adviser: 'TBD',  // Add manually later
      room: 'TBD'
    });
  }
});

console.log(`Found ${sectionsMap.size} unique sections`);

// Step 2: Insert sections
const insertSection = db.prepare(`
  INSERT INTO sections (name, adviser, room)
  VALUES (?, ?, ?)
`);

const sectionIdMap = new Map();  // Map section name to id

sectionsMap.forEach((section, name) => {
  const result = insertSection.run(section.name, section.adviser, section.room);
  sectionIdMap.set(name, result.lastInsertRowid);
  console.log(`âœ… Inserted section: ${name} (ID: ${result.lastInsertRowid})`);
});

// Step 3: Insert students
const insertStudent = db.prepare(`
  INSERT INTO students (student_id, first_name, last_name, age, section_id)
  VALUES (?, ?, ?, ?, ?)
`);

let importedCount = 0;
let errorCount = 0;

jsonData.forEach(student => {
  try {
    // Parse name (assuming "First Last" format)
    const nameParts = student.name.split(' ');
    const firstName = nameParts[0];
    const lastName = nameParts.slice(1).join(' ') || firstName;
    
    // Get section ID
    const sectionId = sectionIdMap.get(student.section);
    
    if (!sectionId) {
      console.log(`âš ï¸  Skipping ${student.name}: Unknown section`);
      errorCount++;
      return;
    }
    
    // Insert student
    insertStudent.run(
      student.studentId,
      firstName,
      lastName,
      student.age,
      sectionId
    );
    
    importedCount++;
    
  } catch (err) {
    console.log(`âŒ Error importing ${student.name}: ${err.message}`);
    errorCount++;
  }
});

console.log('\n=== Import Summary ===');
console.log(`âœ… Imported: ${importedCount} students`);
console.log(`âŒ Errors: ${errorCount}`);
console.log(`ğŸ“Š Total in JSON: ${jsonData.length}`);

db.close();


RUN IMPORT:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

$ node import-json-data.js

Output:
  Found 150 students in JSON file
  Found 5 unique sections
  âœ… Inserted section: Grade 10-A (ID: 1)
  âœ… Inserted section: Grade 10-B (ID: 2)
  ...
  === Import Summary ===
  âœ… Imported: 148 students
  âŒ Errors: 2
  ğŸ“Š Total in JSON: 150


VERIFY IMPORT:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

-- Check section counts
SELECT 
  sections.name,
  COUNT(students.id) as student_count
FROM sections
LEFT JOIN students ON sections.id = students.section_id
GROUP BY sections.id;

-- Sample students
SELECT * FROM students LIMIT 5;


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 PHASE 4: UPDATE APPLICATION CODE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BEFORE: Reading JSON (Part 1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

app.js:
const fs = require('fs');
const path = require('path');

// Read JSON file
app.get('/students', (req, res) => {
  const data = JSON.parse(
    fs.readFileSync(path.join(__dirname, 'students.json'), 'utf8')
  );
  
  res.render('students', { students: data });
});


AFTER: Querying Database (Part 2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

app.js:
const Database = require('better-sqlite3');
const path = require('path');

const db = new Database(path.join(__dirname, 'school.db'));

// Query database
app.get('/students', (req, res) => {
  const students = db.prepare(`
    SELECT 
      students.*,
      sections.name as section_name
    FROM students
    INNER JOIN sections ON students.section_id = sections.id
    ORDER BY students.last_name
  `).all();
  
  res.render('students', { students });
});


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BEFORE: Adding Student (JSON)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

app.post('/students/add', (req, res) => {
  // Read entire file
  const data = JSON.parse(
    fs.readFileSync('students.json', 'utf8')
  );
  
  // Add new student
  data.push({
    id: data.length + 1,
    studentId: req.body.studentId,
    name: req.body.name,
    age: parseInt(req.body.age),
    section: req.body.section
  });
  
  // Write entire file back
  fs.writeFileSync(
    'students.json',
    JSON.stringify(data, null, 2)
  );
  
  res.redirect('/students');
});


AFTER: Inserting into Database
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

app.post('/students/add', (req, res) => {
  // Validate
  const errors = validateStudent(req.body);
  if (errors.length > 0) {
    req.flash('error', errors);
    return res.redirect('/students/add');
  }
  
  // Insert single row
  db.prepare(`
    INSERT INTO students (student_id, first_name, last_name, age, section_id)
    VALUES (?, ?, ?, ?, ?)
  `).run(
    req.body.student_id,
    req.body.first_name,
    req.body.last_name,
    parseInt(req.body.age),
    parseInt(req.body.section_id)
  );
  
  req.flash('success', 'Student added successfully!');
  res.redirect('/students');
});


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BEFORE: Updating Student (JSON)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

app.post('/students/edit/:id', (req, res) => {
  // Read entire file
  const data = JSON.parse(
    fs.readFileSync('students.json', 'utf8')
  );
  
  // Find and update
  const index = data.findIndex(s => s.id === parseInt(req.params.id));
  if (index !== -1) {
    data[index].name = req.body.name;
    data[index].age = parseInt(req.body.age);
    data[index].section = req.body.section;
  }
  
  // Write entire file back
  fs.writeFileSync(
    'students.json',
    JSON.stringify(data, null, 2)
  );
  
  res.redirect('/students');
});


AFTER: Updating Database Row
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

app.post('/students/edit/:id', (req, res) => {
  // Validate
  const errors = validateStudent(req.body);
  if (errors.length > 0) {
    req.flash('error', errors);
    return res.redirect(`/students/edit/${req.params.id}`);
  }
  
  // Update single row
  const result = db.prepare(`
    UPDATE students
    SET first_name = ?, last_name = ?, age = ?, section_id = ?,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = ?
  `).run(
    req.body.first_name,
    req.body.last_name,
    parseInt(req.body.age),
    parseInt(req.body.section_id),
    req.params.id
  );
  
  if (result.changes === 0) {
    req.flash('error', 'Student not found');
  } else {
    req.flash('success', 'Student updated successfully!');
  }
  
  res.redirect('/students');
});


â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BEFORE: Deleting Student (JSON)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

app.post('/students/delete/:id', (req, res) => {
  // Read entire file
  const data = JSON.parse(
    fs.readFileSync('students.json', 'utf8')
  );
  
  // Filter out student
  const filtered = data.filter(s => s.id !== parseInt(req.params.id));
  
  // Write entire file back
  fs.writeFileSync(
    'students.json',
    JSON.stringify(filtered, null, 2)
  );
  
  res.redirect('/students');
});


AFTER: Deleting Database Row
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

app.post('/students/delete/:id', (req, res) => {
  // Get student name for message
  const student = db.prepare(
    'SELECT first_name, last_name FROM students WHERE id = ?'
  ).get(req.params.id);
  
  if (!student) {
    req.flash('error', 'Student not found');
    return res.redirect('/students');
  }
  
  // Delete single row
  db.prepare('DELETE FROM students WHERE id = ?').run(req.params.id);
  
  req.flash('success', `${student.first_name} ${student.last_name} deleted`);
  res.redirect('/students');
});


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 PHASE 5: UPDATE VIEWS (EJS Templates)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BEFORE: Display JSON Data
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

index.ejs:
<% students.forEach(student => { %>
  <tr>
    <td><%= student.id %></td>
    <td><%= student.name %></td>
    <td><%= student.age %></td>
    <td><%= student.section %></td>
  </tr>
<% }); %>


AFTER: Display Database Data (with JOIN)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

index.ejs:
<% students.forEach(student => { %>
  <tr>
    <td><%= student.id %></td>
    <td><%= student.first_name %> <%= student.last_name %></td>
    <td><%= student.age %></td>
    <td><%= student.section_name %></td>  â† From JOIN
    <td><%= new Date(student.created_at).toLocaleDateString() %></td>
  </tr>
<% }); %>


BEFORE: Add Form (Text Input for Section)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

add.ejs:
<input type="text" name="section" placeholder="Grade 10-A" required>


AFTER: Add Form (Dropdown for Foreign Key)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

add.ejs:
<select name="section_id" required>
  <option value="">-- Select Section --</option>
  <% sections.forEach(section => { %>
    <option value="<%= section.id %>">
      <%= section.name %> (Adviser: <%= section.adviser %>)
    </option>
  <% }); %>
</select>


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 PHASE 6: TESTING CHECKLIST
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DATA MIGRATION TESTS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

[ ] All JSON records imported correctly
[ ] Section relationships set up properly
[ ] No duplicate student IDs
[ ] Name parsing (first/last) correct
[ ] Age values within valid range
[ ] Timestamps populated

CRUD OPERATION TESTS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

[ ] List all students (with section info)
[ ] Add new student
[ ] Edit existing student
[ ] Delete student
[ ] Search/filter students
[ ] Sort students

VALIDATION TESTS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

[ ] Duplicate student_id rejected
[ ] Invalid section_id rejected
[ ] Missing required fields rejected
[ ] Age out of range rejected
[ ] Invalid email format rejected

RELATIONSHIP TESTS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

[ ] Transfer student between sections
[ ] Delete section (CASCADE to students)
[ ] Count students per section
[ ] View section details with student list

PERFORMANCE TESTS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

[ ] Large dataset (1000+ students) loads quickly
[ ] Search is instant
[ ] Sorting is fast
[ ] No file locking issues


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 DEPLOYMENT NOTES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

RAILWAY DEPLOYMENT:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Add database to .gitignore
   *.db
   *.db-shm
   *.db-wal

2. Use Railway volumes for persistence
   const dbPath = process.env.RAILWAY_VOLUME_MOUNT_PATH 
     ? path.join(process.env.RAILWAY_VOLUME_MOUNT_PATH, 'school.db')
     : path.join(__dirname, 'school.db');

3. Run setup script after first deployment
   railway run node setup-database.js

4. Import data (optional)
   railway run node import-json-data.js


BACKUP STRATEGY:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Regular database backups
   sqlite3 school.db ".backup backup.db"

2. Export to JSON (for portability)
   const students = db.prepare('SELECT * FROM students').all();
   fs.writeFileSync('backup.json', JSON.stringify(students, null, 2));

3. Automate backups (cron job or scheduled task)


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    KEY TAKEAWAYS                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. Plan schema before migration (normalize data)
2. Create separate migration scripts (setup, import)
3. Verify data import before deploying
4. Update ALL routes (list, add, edit, delete)
5. Update views (dropdowns for foreign keys, show relationships)
6. Test thoroughly (CRUD, validation, relationships)
7. Use Railway volumes for production persistence
8. Keep JSON file as backup during transition
9. Migration is an opportunity to improve data structure
10. Document changes for future reference

ğŸ’¡ REMEMBER: Migration is not just copying data - it's
   improving your application architecture!
</pre>